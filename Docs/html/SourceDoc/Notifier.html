<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="robots" content="index,nofollow">


<title>SourceDoc/Notifier - Freevo 2.0 Wiki</title>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="../modern/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="../modern/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="../modern/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" href="../modern/css/freevo.css">

<link rel="alternate" title="Freevo 2.0 Wiki Recent Changes" href="/cgi-bin/freevo-2.0/RecentChanges?action=rss_rc&amp;ddiffs=1&amp;unique=1" type="application/rss+xml">
<link rel="Start" href="/cgi-bin/freevo-2.0/Index">
<link rel="Alternate" title="Wiki Markup" href="/cgi-bin/freevo-2.0/SourceDoc/Notifier?action=raw">
<link rel="Alternate" media="print" title="Print View" href="/cgi-bin/freevo-2.0/SourceDoc/Notifier?action=print">
<link rel="Up" href="/cgi-bin/freevo-2.0/SourceDoc">
<link rel="Search" href="/cgi-bin/freevo-2.0/FindPage">
<link rel="Index" href="/cgi-bin/freevo-2.0/TitleIndex">
<link rel="Glossary" href="/cgi-bin/freevo-2.0/WordIndex">
<link rel="Help" href="/cgi-bin/freevo-2.0/HelpOnFormatting">
</head>

<body  lang="en" dir="ltr">

            <!-- Header Logo and Status Line -->
<div id="titlebar"><span class="name"><a href="http://freevo.sourceforge.net/" target="_blank">Freevo</a></span></div>
<div id="header">
<ul>

	<li><a href="../Index.html">User Documentation</a></li>
	<li id="current"><a href="../SourceDoc.html">Source Documenation</a></li>
        
</ul>
</div>
<p>&nbsp;</p>
<div id="page" lang="en" dir="ltr"><!-- start page -->


<h1 id="title">SourceDoc/Notifier</h1>
<div lang="en" id="content" dir="ltr">
<a id="top"></a>
<ol>

<li>
<a href="#head-f7fc3a39f051d124dad94023af1a29418972f196">Introduction</a>
</li>

<li>
<a href="#head-b9348352cb263ec32411709b6cd135aadb78a460">API</a>
<ol>

<li>
<a href="#head-741b7fd449c35d19d1286188f52b8dcc3dedacb1">Sockets</a>
</li>

<li>
<a href="#head-976fc205b9396cea3569802ce852c2f16a3210e8">Timer</a>
</li>

<li>
<a href="#head-6122f9f5373c59355645dfd8d5e4e1d559b8c000">External Dispatcher</a>
</li>

<li>
<a href="#head-a7254c4fc42c1ed2503cd639201e6fb2d210e796">Callbacks</a>
</li>

</ol>

</li>

</ol>
<p> </p>

<h2 id="head-f7fc3a39f051d124dad94023af1a29418972f196">Introduction</h2>

<p>To be notified or to be threaded that is the question! </p>
<p>As the package name may suggest, pyNotifier is a notifier/event scheduler abstraction written in python. It implements notification mechanisms for socket events (read or write) and timers. Additionally external event dispatchers may be called during an idle period. </p>
<p>Applications using such an notifier mechanism implemented by pyNotifier have a specific software architecture. These applications are interactive, meaning that almost all action is only done because an event occured that was watched by the application. For example a server appliciation has to react if there is data waiting on a socket or the socket is again ready to write data to the network. Some applications may need to act in a recurrently interval of time. Another type of interaction can be found in applications having a graphical user interface. </p>
<p>Most applications of the described type do not need threads. Threading is a mechanism that may help to solve some problems, but in most cases it causes more problems than it solves. Threads are very often used to process two or more tasks in parallel. The belief that threads are the solution to this problem is a fallacy. The only solution to this prolbem is the existence of several CPUs. A quasi parallel order of events may be solved by using threads, but can also be solved by using a notifier. When using threads the critical sections of the programs must be locked by using adequate algorithm as the thread scheduler may interrupt a function at any point. By using a notifier this problems are irrelevant as a notifier just schedules the next event, when the handler of the previous event is finished. i.e. there are no critcal sections that have to be protected. Being able to forego on any kind of protection for critical sections reduces the length and increases the clarity of the source code. </p>
<p>Application programmers who want to use a notifier/event scheduler based architecture for their software may run into one problem when trying to implement a graphical user interface for the X11 Window System. As the X11 window system itself uses a event based architecture all known widget set implementations are also based on such mechanisms. Examples for such widget sets are GTK+, Qt or wxWindows. The problem is that these software packages implement their own notifier/event schedulers. To solve this problem pyNotifier provides the possibility to wrap the notifier of a selected widget set, so that applications using the pyNotifier API may still be able to use a widget set without the need to convert their code to the notifier API of the widget set. Currently wrappers for the previously listed widget sets are available. </p>

<h2 id="head-b9348352cb263ec32411709b6cd135aadb78a460">API</h2>

<p>An application using pyNotifier has to initialise the notifier, i.e. it has to choose which notifier implementation should be used. This is done by calling the 'init' function </p>

<pre>
def init( type = GENERIC ):
</pre>
<p>If no argument is given to the 'init' function the internal implementation of pyNotifier is used. Other possible choices for the 'type' argument are GTK, QT and WX (current support for wxWindows is not up-to-date). </p>

<h3 id="head-741b7fd449c35d19d1286188f52b8dcc3dedacb1">Sockets</h3>

<p>To get notified when a specific event occurs the application has to register its interest for this event. For sockets and files this is done with the 'addSocket' function'. </p>

<pre>
def addSocket( id, method, condition = IO_IN )
</pre>
<p>The 'id' argument may be a socket or file object or a file descriptor that can be retrieved by calling the 'fileno()' member function of these objects. The second argument 'method' has to be a callable python object that is invoked by the notifier if the registered event has occured. The function is invoked with the 'id' as an argument. Instead of a normal function the [@callbacks 'Callback'] object provided by pyNotifier may be usful at this point. </p>
<p>To remove a registered socket or file from the notifier the 'removeSocket' function has to be invoked. The 'id' is the socket or file object or the file descriptor given to 'addSocket' and the optional argument 'condition' may be set to IO_IN or IO_OUT depending on the prevuoisly registered event. </p>

<pre>
def removeSocket( id, condition = IO_IN )
</pre>
<p>Another way to achieve the removal of a socket or file object from the notifier is to return False in the callback function. If a callback function returns False or nothing it is removed at the application is never again triggered if this specific event occurs. </p>

<h3 id="head-976fc205b9396cea3569802ce852c2f16a3210e8">Timer</h3>

<p>pyNotifier supports just one type of timer. If a timer is registered for a given interval of time the application is recurrently triggered when the timer expires. To register a timer the 'addTimer' function has to be invoked. The first argument 'interval' must be specified in milliseconds. 'method' is the callback function that is invoked by the notifier without any argument when the timer expires. </p>

<pre>
def addTimer( interval, method ) -&gt; unique timer identifier
</pre>
<p>To implement a one-shot timer that is just triggered once and never again the application can use the return value of its callback function for this timer and return False or None. In this case the notifier automatically removes the timer. Another way to remove a timer is to call the method 'removeTimer'. </p>

<pre>
def removeTimer( id )
</pre>
<p>The 'id' argument is the unique timer identifier returned by 'addTimer'. </p>

<h3 id="head-6122f9f5373c59355645dfd8d5e4e1d559b8c000">External Dispatcher</h3>

<p>All already described tasks of an applications are scheduled by events that have occured on sockets or files or by pre-defined recurrently time intervals. But some applications may also have some tasks that may not need to be scheduled by any events or an exact timing. These tasks should be repeated quite often, if there is some time to do it. </p>
<p>pyNotifier provides the feature to add so called external dispatchers. These dispatchers are functions that will be invoked in each notifier step after all timers and sockets were checked. To add a dispatcher function to the notifier main loop the function 'addDispatcher' is provided. The only argument to this function is the callback methodthat will be called. </p>

<pre>
def addDispatcher( method )
</pre>
<p>To remove such a dispatcher function from the notifier main loop 'removeDispatcher' is used with the call back method as the only argument. </p>

<pre>
def removeDispatcher( method )
</pre>
<a id="callbacks"></a>
<p> </p>

<h3 id="head-a7254c4fc42c1ed2503cd639201e6fb2d210e796">Callbacks</h3>

<p>pyNotifier provides a class 'Callback' that can be used as a callback function that is passed to the 'addSocket' and 'addTimer' function. This class provides the possibility to pass more than the specified arguments to the callback functions. For example the socket callback function is called with one single argument. To pass some state information to the callback function the 'Callback' object may be used. A default callback function for a socket event would look like 'socket1'. </p>

<pre>
import notifier
...
notifier.addSocket( fd, socket1 )
...

def socket1( fd ):
    print 'data received on socket', fd
</pre>
<p>'fd' is the 'id' given to 'addSocket'. To pass some state information to the callback function it can be done as shown in the following example. </p>

<pre>
import notifier
...
notifier.addSocket( fd, notifier.Callback( arg1, arg2 ) )
...

def socket1( fd, arg1, arg2 ):
    print 'data received on socket', fd
    print 'additional state information', arg1, arg2
</pre>
<p>The arguments given to the Callback object are appended to the original list of arguments for the callback function. The argument list to the Callback object can be of any length. </p>
<p>Any comments or questions can be send to </p>
<p><a href="mailto:python@crunchy-home.de"><img src="../modern/img/moin-email.png" alt="[MAILTO]" height="10" width="14"> python@crunchy-home.de</a> </p>
<a id="bottom"></a>

</div>
<p id="pageinfo" class="info" lang="en" dir="ltr">last edited 2004-12-18 16:40:37 by <span title="adsl-9-69.nordcom.uni-bremen.de">crunchy</span>
<br>current version: <a href="http://freevo.sourceforge.net/cgi-bin/freevo-2.0/SourceDoc/Notifier">http://freevo.sourceforge.net/cgi-bin/freevo-2.0/SourceDoc/Notifier</a></p>
</div> <!-- end page -->
</body>
</html>
